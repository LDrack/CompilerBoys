#include "SymbolTable.h"
#include "SymbolFactory.h"
#include "Kind.h"
#include "OpKind.h"
#include "DACGenerator.h"
#include "DACEntry.h"
#include "DACFactory.h"
#include "Type.h"
// #include <string>
#include <charconv>
// #include <system_error>


COMPILER MIEC

    SymbolTable   *tab;
    SymbolFactory *fac;
    DACGenerator dac;
    
    // CodeGenerator *gen;

    void Err(wchar_t* msg) {
        errors->Error(la->line, la->col, msg);
    }

    // int // types
    //   undef, Integer;

    // void InitDeclarations() { // it must exist
    //     undef = 0; Integer = 1; // types
    // }


    const Type *getIntegerType() {
      std::wstring typeName = L"[Type]Integer";
      std::shared_ptr<Symbol> sym = tab->Find(typeName);
      if (!sym || sym->GetKind() != Kind::eType) {
        std::shared_ptr<Symbol> typeSym = fac->CreateTypeSym(typeName, Kind::eInt);
        sym = tab->Insert(std::move(typeSym));
      }
      return &(sym->GetKind());
    }


  
CHARACTERS
  letter = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".
  digit = "0123456789".
  cr  = '\r'.
  lf  = '\n'.
  tab = '\t'.

/*--------------------------------------------------------------------------*/
TOKENS
  ident  = letter {letter | digit}.
  number = digit {digit}.
  
    
COMMENTS
  FROM "(*" TO "*)" NESTED


IGNORE cr + lf + tab


/*--------------------------------------------------------------------------*/
PRODUCTIONS
  MIEC =  "PROGRAM" ident
          "BEGIN_VAR"
          [VarDecl]
          "END_VAR"
          "BEGIN"
          Statements
          "END" .


  VarDecl =                 (. wchar_t* name; Kind type; .)
  Ident<name> ":"
  Type<type> ";"            (. if(!tab->Add( name, type)){Err(L"Insert new var failed");} .)
  {Ident<name> ":"
  Type<type> ";"            (. if(!tab->Add( name, type)){Err(L"Insert new var failed");} .)}
          .




/*------------------------------------------------------------------------*/




Statements = Stat { Stat } .


Stat =                                                  (. std::unique_ptr<DACEntry> entry; .)
InstructionLine<entry>                                  (. dac.AddStat(std::move(entry)) .)
| Controlblock
.



InstructionLine<. std::unique_ptr<MIEC::DACEntry> &entry .> = (
  Assignment<entry>
  | Print<entry>
) ";"
.



Print<. std::unique_ptr<MIEC::DACEntry> &entry .> = 
                                                      (. std::unique_ptr<MIEC::DACEntry> expr; .)
  "print" "(" Expr<expr> ")" 
                                                      (. entry = MIEC::DACFactory::createEntry(OpKind.ePrint, 
                                                            MIEC::DACFactory::createDACOperand(std::move(expr))); .)
.



Controlblock =
  WhileLoop |
  ConditionalBlock .



WhileLoop = 
                                          (. std::unique_ptr<MIEC::DACEntry> cond; .)
  "WHILE" Condition<cond> "DO"
                                          (.  auto endLabel = MIEC::DACFactory::createEntry(OpKind::eNop,
                                              nullptr, nullptr, L"While: END")

                                              auto startLoopLabel = MIEC::DACFactory::createEntry(OpKind::eIfFalseJump,
                                              MIEC::DACFactory::createDACOperand(std::move(cond)),
                                              MIEC::DACFactory::createSymOperand(std::move(endLabel)),
                                              L"While: Jump to END");

                                              auto endLoopLabel = MIEC::DACFactory::createEntry(OpKind::eJump,
                                              MIEC::DACFactory::createSymOperand(std::move(startLoopLabel)),
                                              nullptr,
                                              L"While: Jump to start");
                                              
                                              dac.AddStat(std::move(startLoopLabel));
                                          .)  
    [ Statements ]  
  "END"
                                          (.  dac.AddStat(std::move(endLoopLabel));
                                              dac.AddStat(std::move(endLabel));
                                          .) 
  .



ConditionalBlock =
                                          (.  std::unique_ptr<MIEC::DACEntry> cond; .)
  "IF" Condition<cond> "THEN"
                                          (.  auto endLabel = MIEC::DACFactory::createEntry(OpKind::eNop,
                                              nullptr, nullptr, L"If: END")

                                              auto elseLabel = MIEC::DACFactory::createEntry(OpKind::eNop,
                                              nullptr, nullptr, L"If: else");

                                              auto afterIfLabel = MIEC::DACFactory::createEntry(OpKind::eJump,
                                              MIEC::DACFactory::createDACOperand(std::move(endLabel)),
                                              nullptr,
                                              L"If: Jump over else to END");

                                              auto startIfLabel = MIEC::DACFactory::createEntry(OpKind::eIfFalseJump,
                                              MIEC::DACFactory::createDACOperand(std::move(cond)),
                                              MIEC::DACFactory::createSymOperand(std::move(elseLabel)),
                                              L"If: Jump to else");
                                              
                                              dac.AddStat(std::move(startIfLabel));
                                          .)  
    [ Statements ]
                                          (.  dac.AddStat(std::move(afterIfLabel));
                                              dac.AddStat(std::move(elseLabel));
                                          .) 
  [ "ELSE" 
    [ Statements ]
  ]
  "END"
                                          (.  dac.AddStat(std::move(endLabel));  .)
  .




/*------------------------------------------------------------------------*/




Condition<. std::unique_ptr<MIEC::DACEntry> &entry .> = (. OpKind opKind;
                                                    std::unique_ptr<MIEC::DACEntry> op, op2; .)
 Expr<op>
{ Relop<opKind>
  Expr<op2>
                                  (. op = MIEC::DACFactory::createEntry(opKind,
                                             MIEC::DACFactory::createDACOperand(std::move(op)),
                                             MIEC::DACFactory::createDACOperand(std::move(op2)));
                                  .)
}
                                  (. entry = std::move(op) .)
.



Assignment<. std::unique_ptr<MIEC::DACEntry> &entry .> =  (.wchar_t* name;
                                                    Type* type = nullptr;
                                                    Symbol* sym = nullptr;
                                                    std::unique_ptr<MIEC::DACEntry> expr; .)
  Ident<name>                                       (.  sym = tab->Find(name).get();
                                                    if (sym == nullptr) Err(L"Variable not defined");  .)

 ":=" Expr<expr>                                    (. entry = MIEC::DACFactory::createEntry(OpKind.eAssign,
                                                            MIEC::DACFactory::createSymOperand(sym),
                                                            MIEC::DACFactory::createDACOperand(expr));
                                                    .)
.



Expr<. std::unique_ptr<MIEC::DACEntry>& entry .> = (.OpKind opKind;
                                                      std::unique_ptr<MIEC::DACEntry> op; 
                                                      std::unique_ptr<MIEC::DACEntry> op2; .)
    Term<op>
    { AddOp<opKind>
      Term<op2>
                                                      (.op = MIEC::DACFactory::createEntry(opKind,
                                                          MIEC::DACFactory::createDACOperand(std::move(op)),
                                                          MIEC::DACFactory::createDACOperand(std::move(op2)));
                                                        .)
    }
                                                      (. entry = std::move(op) .)
.



  Term<. std::unique_ptr<DACEntry> &entry .> = (. OpKind opKind;
                                                 std::unique_ptr<MIEC::Operand> op, op2; .)
  Fact<op> 
  { MulOp<opKind>
    Fact<op2>
                                    (. op = MIEC::DACFactory::createEntry(opKind,
                                               std::move(op),
                                               std::move(op2));
                                    .)
  }
                                    (. entry = std::move(op) .)
  .




  Fact<. std::unique_ptr<MIEC::Operand> &entry .> =               (. int value; wchar_t* name; std::unique_ptr<MIEC::DACEntry> op; Symbol* sym; .)
  Ident<name>                       (. sym = tab->Find(name); if(sym == nullptr){Err(L"Variable not defined");}
                                       entry = new SymOperand(sym); .)
  | Number<value>                   (. sym = tab->Find(value); if(sym == nullptr){sym = tab->Add(value);}
                                       entry = new SymOperand(sym); .)
  | "(" Expr<op> ")"                (. entry = MIEC::DACFactory::createDACOperand(std::move(op)); .)
  .




  Relop < OpKind op > = "="         (.op = OpKind::eIsEqual; .)
                      | "<="        (.op = OpKind::eIsLessEqual; .)
                      | ">="        (.op = OpKind::eIsGreaterEqual; .)
                      | "!="        (.op = OpKind::eIsNotEqual; .)
                      | "<"         (.op = OpKind::eIsLess; .)
                      | ">"         (.op = OpKind::eIsGreater; .)
                      .

/*------------------------------------------------------------------------*/
  Ident<wchar_t* &name>
= ident                  (. name = coco_string_create(t->val); .)
.

/*------------------------------------------------------------------------*/
Number<int& value> = 
number                    (. int ret = swscanf(t->val, L"%d", &value);
                             if (ret < 1) Err(L"parsing number failed"); .)
.

/*------------------------------------------------------------------------*/
Type<Kind &type>
=                        (. type = Kind::eUndef; .)
 ( "Integer"             (. type = Kind::eInt; .)
 ).

/*------------------------------------------------------------------------*/
MulOp<OpKind op>
=
  ( '*'                  (. op = OpKind::eMultiply; .)
  | '/'                  (. op = OpKind::eDivide; .)
  ).
/*------------------------------------------------------------------------*/
AddOp<OpKind op>
=
  ( '+'	                 (. op = OpKind::eAdd; .)
  | '-'                  (. op = OpKind::eSubtract; .)
  ).

/* MIEC = . */


END MIEC .
